# -*- mode: sh; -*-

# git rev-parse --show-toplevel
# git rev-parse --is-inside-git-dir
# git rev-parse --is-inside-work-tree
# git rev-parse --short=0 HEAD
# git symbolic-ref --short HEAD || git rev-parse --abbrev-ref HEAD
# git log --left-right --graph --cherry-pick --oneline @{u}..

alias t='tig'

# Git alias shell-completion.
__define_git_completion() {
eval "
  _git_$2_shortcut() {
    COMP_LINE=\"git $2\${COMP_LINE#$1}\"
    let COMP_POINT+=$((4+${#2}-${#1}))
    COMP_WORDS=(git $2 \"\${COMP_WORDS[@]:1}\")
    let COMP_CWORD+=1

    local cur words cword prev
    _get_comp_words_by_ref -n =: cur words cword prev
    _git_$2
  }
"
}

# TEST THIS...
__git_shortcut() {
  local shortcut="${1}"
  type "_git_${2}_shortcut" &>/dev/null || __define_git_completion "${1}" "${2}"
  "${shortcut}"() { 'git ${2} ${3}' }
  complete -o default -o nospace -F "_git_${2}_shortcut" "${1}"
}

# Quote argument $3 if it contains spaces.
__git_shortcut  ga  add
__git_shortcut  gA  add --all
__git_shortcut  gb  branch
__git_shortcut  gbv  branch '--color -v | cut -c1-100'
__git_shortcut  gc  commit '-v -m'
__git_shortcut  gd  diff
__git_shortcut  gco  checkout
__git_shortcut  gcoA  checkout '-- .'
__git_shortcut  gcoB  checkout -b
__git_shortcut  gconf  cat './.git/config'
__git_shortcut  gFA  fetch --all
__git_shortcut  gPo  push "origin $(git rev-parse --abbrev-ref HEAD)"
__git_shortcut  gPoF  push "origin -f $(git rev-parse --abbrev-ref HEAD)"
__git_shortcut  gpLUM  pull '--ff-only upstream master'
__git_shortcut  gpLR  pull --rebase
__git_shortcut  gRi  rebase -i
__git_shortcut  gRom  rebase 'origin/master'
__git_shortcut  grm  commit '-F .git/MERGE_MSG'
__git_shortcut  gsh  show
__git_shortcut  gst  status

# delete all local tracking branches except master ->
#    'git branch | grep -v "master" | xargs git branch -D'

# Usage: git-in-repo
# Test if we are currently under version control with git.
git-in-repo() {
  if ! git branch >/dev/null 2>&1; then
    err "Error: '$(basename ${PWD})' is not a git repository."
      return 1
  else
      return 0
  fi
}

# Usage: git-commit-for-squash
# Make a commit for a projected squashing.
git-commit-for-squash() {
  git add . && git commit -v -m "SQUASH ME"
}

# Usage: git-conflict-cherry-pick $PARENT_BRANCH $HASH
# Apply a $HASH to the HEAD of the current branch after updating it to
# be a clone of the supplied $PARENT_BRANCH.
git-conflict-cherry-pick() {
  if [[ "$#" -ne 2 ]]; then
    err "Usage: git-conflict-cherry-pick \$PARENT_BRANCH \$HASH"
  else
    git-in-repo;
    if [[ $? -eq 0 ]]; then
      git reset --hard "$1" && git cherry-pick "$2"
    fi
  fi
}

# Usage: git-minimum-hash
# Print the entire SHA1 commit hash of the current HEAD with the
# minimum hash highlighted.
git_minimum_hash() {
  git rev-parse HEAD \
    | GREP_COLORS='ms=34;1' grep "$(git rev-parse --short=0 HEAD)"
}

# Usage: git-grep-replace $TARGET $NEW
# Replace a $TARGET string with a $NEW string repo-wide.
git_grep_replace() {
  git grep --full-name --files-with-matches "$1" \
    | xargs sed --in-place -e "s/$1/$2/"
}
