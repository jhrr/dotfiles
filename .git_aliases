# -*- mode: sh; -*-

# git rev-parse --show-toplevel
# git rev-parse --is-inside-git-dir
# git rev-parse --is-inside-work-tree
# git rev-parse --short=0 HEAD
# git symbolic-ref --short HEAD || git rev-parse --abbrev-ref HEAD
# git log --left-right --graph --cherry-pick --oneline @{u}..

alias gA='git add --all'
alias gb='git branch'
alias gbv='git branch --color -v | cut -c1-150'
alias gc='git commit -v -m'
alias gd='git diff'
alias gco='git checkout'
alias gcoA='git checkout -- .'
alias gcoB='git checkout -b'
alias gconf='cat ./.git/config'
alias gFA='git fetch --all'
alias gPo='git push origin $(git rev-parse --abbrev-ref HEAD)'
alias gPoF='git push origin -f $(git rev-parse --abbrev-ref HEAD)'
alias gpLU='git pull --ff-only upstream master'
alias gpLR='git pull --rebase'
alias gRi='git rebase -i'
alias gRom='git rebase origin/master'
alisa grm='git commit -F .git/MERGE_MSG'
alias gsh='git show'
alias gst='git status'
alias t='tig'

# delete all local tracking branches except master ->
#    'git branch | grep -v "master" | xargs git branch -D'

# Usage: git-in-repo
# Test if we are currently under version control with git.
git-in-repo() {
  if ! git branch >/dev/null 2>&1; then
    err "Error: '$(basename ${PWD})' is not a git repository."
      return 1
  else
      return 0
  fi
}

# Usage: git-conflict-cherry-pick $PARENT_BRANCH $HASH
# Apply a $HASH to the HEAD of the current branch after updating it to
# be a clone of the supplied $PARENT_BRANCH.
git-conflict-cherry-pick() {
  if [[ "$#" -ne 2 ]]; then
    err "Usage: git-conflict-cherry-pick \$PARENT_BRANCH \$HASH"
  else
    git-in-repo;
    if [[ $? -eq 0 ]]; then
      git reset --hard "$1" && git cherry-pick "$2"
    fi
  fi
}

# Usage: git-minimum-hash
# Print the entire SHA1 commit hash of the current HEAD with the
# minimum hash highlighted.
git_minimum_hash() {
  git rev-parse HEAD \
    | GREP_COLORS='ms=34;1' grep "$(git rev-parse --short=0 HEAD)"
}

# Usage: git-grep-replace $TARGET $NEW
# Replace a $TARGET string with a $NEW string repo-wide.
git_grep_replace() {
  git grep --full-name --files-with-matches "$1" \
    | xargs sed --in-place -e "s/$1/$2/"
}


# Git alias shell-completion.
# __define_git_completion() {
# eval "
#   _git_$2_shortcut() {
#     COMP_LINE=\"git $2\${COMP_LINE#$1}\"
#     let COMP_POINT+=$((4+${#2}-${#1}))
#     COMP_WORDS=(git $2 \"\${COMP_WORDS[@]:1}\")
#     let COMP_CWORD+=1

#     local cur words cword prev
#     _get_comp_words_by_ref -n =: cur words cword prev
#     _git_$2
#   }
# "
# }

# __git_shortcut() {
#   type "_git_$2_shortcut" &>/dev/null || __define_git_completion "$1" "$2"
#   alias $1='git $2 $3'
#   complete -o default -o nospace -F "_git_$2_shortcut" "$1"
# }

# __git_shortcut  ga     add
# __git_shortcut  gbv    branch '--color -v | cut -c1-100'
# __git_shortcut  gc     commit '-v -m'
# __git_shortcut  grm    commit '-F .git/MERGE_MSG'
