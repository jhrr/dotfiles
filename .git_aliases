# -*- mode: sh; -*-

# git rev-parse --show-toplevel
# git rev-parse --is-inside-git-dir
# git rev-parse --is-inside-work-tree
# git rev-parse --short=0 HEAD
# git symbolic-ref --short HEAD || git rev-parse --abbrev-ref HEAD
# git log --left-right --graph --cherry-pick --oneline @{u}..

alias gcoA='git checkout -- .'
alias gcoB='git checkout -b'
alias gconf='cat ./.git/config'
alias gPo='git push origin $(git rev-parse --abbrev-ref HEAD)'
alias gPoF='git push origin -f $(git rev-parse --abbrev-ref HEAD)'
alias gpLU='git pull --ff-only upstream master'
alias gRom='git rebase origin/master'
alias t='tig'

# delete all local tracking branches except master ->
#    'git branch | grep -v "master" | xargs git branch -D'

# Usage: git-in-repo
# Test if we are currently under version control with git.
git-in-repo() {
  if ! git branch >/dev/null 2>&1; then
    err "Error: '$(basename ${PWD})' is not a git repository."
      return 1
  else
      return 0
  fi
}

# Usage: git-conflict-cherry-pick $PARENT_BRANCH $HASH
# Apply a $HASH to the HEAD of the current branch after updating it to
# be a clone of the supplied $PARENT_BRANCH.
git-conflict-cherry-pick() {
  if [[ "$#" -ne 2 ]]; then
    err "Usage: git-conflict-cherry-pick \$PARENT_BRANCH \$HASH"
  else
    git-in-repo;
    if [[ $? -eq 0 ]]; then
      git reset --hard "$1" && git cherry-pick "$2"
    fi
  fi
}

# Usage: git-minimum-hash
# Print the entire SHA1 commit hash of the current HEAD with the
# minimum hash highlighted.
git_minimum_hash() {
  git rev-parse HEAD \
    | GREP_COLORS='ms=34;1' grep "$(git rev-parse --short=0 HEAD)"
}

# Usage: git-grep-replace $TARGET $NEW
# Replace a $TARGET string with a $NEW string repo-wide.
git_grep_replace() {
  git grep --full-name --files-with-matches "$1" \
    | xargs sed --in-place -e "s/$1/$2/"
}
