# -*- mode: sh; -*-
# vi: set ft=sh :

[[ "${IS_OSX}" == true ]] &&
  alias ls='gls'

alias ..='cd ..'
alias .2='cd ../..'
alias .3='cd ../../../'
alias .4='cd ../../../../'
alias .5='cd ../../../../..'
alias curldump='curl --trace -'
alias delpyc='find . -name '\*.pyc' -ls -exec rm {} \;'
alias du='du -h -c'
alias du1='du -h --max-depth=1'
alias enx='vim ${HOME}/.nixpkgs/config.nix'
alias exm='ec ${HOME}/.xmonad/xmonad.hs'
alias grd='ls -aliF | ${GREPPAGE} -i'
alias h='history | ${GREPPAGE} -i'
alias kcC='keychain --clear'  # safely decache keychain keys
alias l='ls -halG --color'
alias lift='sudo $(history -p \!\!)'  # sudo previous command
alias myip='curl --silent http://tnx.nl/ip; printf "\n"'
alias npmID='npm i -D'
alias npmIS='npm i -S'
alias open='xdg-open &>/dev/null'
alias p='ipython3'
alias passc='pass -c'
alias psql='sudo -i -u postgres psql'
alias qp='ping -c 5 8.8.8.8'
# TODO: push pwd to stack and pop back when server closes?
alias rds='cd `gh` && reset && ./manage.py runserver_plus --configuration=Dev'
alias shclr='msgcat --color=test'
if [[ "${IS_OSX}" == true ]]; then
  alias shred='gshred -zuv'
else
  alias shred='shred -zuv'
fi
alias startpg='pg_ctl -D /usr/local/var/postgres -l ${HOME}/.postgres-log start'
alias stoppg='pg_ctl -D /usr/local/var/postgres -l ${HOME}/.postgres-log stop'
alias reload='. ${HOME}/.bash_profile'
alias td='tree -d'
alias tv1='xset s off && xset -dpms && echo "screen powersaving off..."'
alias tv0='xset s default && xset +dpms && echo "screen powersaving on..."'
alias txa='tmux attach'
alias txd='tmux detach'
alias txl='tmux ls'
alias txn='tmux attach -t'
alias txs='tmux switch -t'
alias x='startx'
alias vssh='vagrant ssh'
alias vv='${EDITOR} ${HOME}/.vimrc'

alias sue='sudo emacs -nw'
alias v='${VISUAL}'
alias suv='sudo ${VISUAL}'

# Usage: add-vim-plugin "http://some.url/to/a/git/repo"
add-vim-plugin() {
  git -C ~/.vim/bundle submodule add "$@";
}

# Usage: cp-p $SOURCE $DESTINATION
# Copy with progress info.
cp-p() {
  rsync -WavP --human-readable --progress "$1" "$2";
}

django-collect-requirements() {
  if [[ -n "${VIRTUAL_ENV}" ]]; then
    if [[ -f ./requirements-to-freeze.txt ]]; then
      pip install -r requirements-to-freeze.txt --upgrade &&
      pip freeze > requirements.txt
    else
     err "This repo is not using a dual requirements.txt workflow"
    fi
  else
    err "Not currently in an active virtualenv"
  fi
}

# Usage: err "Unable to do_something"
# Stderr helper function.
err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2;
  # exit 1
}

extract() {
  if [[ -f "${1}" ]]; then
    case "${1}" in
      *.tar.bz2)   tar xvjf "${1}"     ;;
      *.tar.gz)    tar xvzf "${1}"     ;;
      *.bz2)       bunzip2 "${1}"      ;;
      *.rar)       unrar x "${1}"      ;;
      *.gz)        gunzip "${1}"       ;;
      *.tar)       tar xvf "${1}"      ;;
      *.tbz2)      tar xvjf "${1}"     ;;
      *.tgz)       tar xvzf "${1}"     ;;
      *.zip)       unzip "${1}"        ;;
      *.Z)         uncompress "${1}"   ;;
      *.7z)        7z x "${1}"         ;;
      *)           echo "${1} cannot be extracted via >extract<" ;;
    esac
  else
    err "Error: ${1} is not a valid file"
  fi
}

# TODO: Consider using '*/\.*', also 'node_modules'?
ff() {
  find . -not -iwholename '*.git*' \
    -not -name '*.pyc' \
    -type f -iname "*""$*""*";
}

# Usage: fx FILE-IDENTIFIER COMMAND
# Execute a command over the results of a call to `find'.
fx() {
  find . -not -iwholename '*.git*' \
    -not -name '*.pyc' \
    -type f -iname "*""${1:-}""*" \
    -exec "${2:-file}" {} \;  ;
}

# Usage: frep REGEX FILE-SPECIFIER
# Grep for patterns over the results of a call to `find'.
frep() {
  find . -not -iwholename '*.git*' \
    -not -name '*.pyc' \
    -name "${2}" -print0 \
    | xargs -0 ack -i "${1}";
}

fwc() {
  find . -name "*.${1}" -print0 \
    | xargs -0 wc -l;
}

# Usage: generate-timestamped-ssh-key DOMAIN
generate-timestamped-ssh-key() {
  if [[ -n $1 ]]; then
    local timestamp comment ssh_host
    timestamp="$(date -u +"%Y%m%dT%H%M%Z")"
    comment="$(whoami)@$(hostname)-$timestamp-rsa"
    ssh_host="$(whoami)@$1-$timestamp-rsa"
    ssh-keygen -f "${HOME}/.ssh/$ssh_host" -C "$comment"
  else
    err "Please provide the ssh server's domain name"
  fi
}

grep-less() {
  "${GREPPAGE}" --color -ir "$1" "$2" | less;
}
alias g='grep-less'

# Grep for "TODO" or "todo" anywhere from and below
# this point in the file hierarchy.
grep-todo() {
  grep-less "todo";
}
alias gtodo='grep-todo'

md() {
  mkdir -p "$@" && cd "$@" || exit;
}

# Usage: npm-do EXECUTABLE COMMANDS
# Find local npm executables to invoke.
npm-do() {
  (PATH=$(npm bin):$PATH; eval "$@";)
}

pip-grep() {
  pip search "$1" \
    | grep -i "$1";
}

pskill() {
  local pid
  pid=$(pgrep -f "$1")
  printf "Killing: %s\n" "$pid"
  kill -9 "$pid"
}

routerip() {
  netstat -nr \
    | awk '$1 == "0.0.0.0" {print $2}';
}

[[ "${IS_LINUX}" == true ]] &&
  sreboot() {
      if [[ "t" == "$(server_ok)" ]]; then
        echo "Shutting down the emacs server..."
        emacsclient -e '(client-save-kill-emacs)'
      fi
      echo "Shutting down MPD..."
      mpd --kill
      sudo shutdown -r now
  }

# Emacs daemon functions.

emacs_server_ok() {
  emacsclient -a "false" -e "(boundp 'server-process)";
}

# Open a file, in the current shell, using the emacs daemon.
e() {
  if [[ "${1}" == '' ]]; then
    emacsclient --tty  .
  else
    emacsclient --tty "${1}"
  fi
}

# Open a file, in the current shell, using no config or daemon.
et() {
  if [[ "${1}" == '' ]]; then
    emacs --no-window-system --quick .
  else
    emacs --no-window-system --quick "${1}"
  fi
}

# Open a file, in the current frame, using the emacs daemon.
emc() {
  if [[ "${1}" == '' ]]; then
    emacsclient --no-wait .
  else
    emacsclient --no-wait "${1}"
  fi
}

 # Open a file, in a new frame, using the emacs daemon.
en() {
  if [[ "${1}" == '' ]]; then
    emacsclient --no-wait --create-frame .
  else
    emacsclient --no-wait --create-frame "${1}"
  fi
}

# Shutdown the running emacs daemon if the server-process is bound
# and the server is in a good state.
ek() {
  if [[ "t" == "$(emacs_server_ok)" ]]; then
    echo "Shutting down the emacs server"
    emacsclient -e '(kill-emacs)'
  else
    err "Error: Emacs server not running"
  fi
}

# Safely shutdown and restart the emacs daemon.
ers() {
  if [[ "t" == "$(emacs_server_ok)" ]]; then
    echo "Shutting down the emacs server..."
    emacsclient -e '(kill-emacs)'
    echo "Restarting the emacs server..."
    emacs -u "${USER}" --daemon --eval '(server-start)'
    emacsclient --no-wait --create-frame
  else
    err "Error: Emacs server not running, cannot restart. Try invoking: 'esd'"
  fi
}
